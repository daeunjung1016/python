#include <stdio.h>

void main() {
	// 배열
	// 하나의 변수에 둘 이상의 값을 저장할 수 있는 구조

	// 배열의 장점
	// 여러 개의 데이터를 한 번에 모아서 저장할 수 있고
	// 변수를 여러 개 만들지 않아도 된다는 장점이 있음

	// 배열의 선언
	// 배열도 변수와 마찬가지로 선언 및 초기화 과정을 거쳐
	// 메모리에 저장된다
	// 배열을 선언하기 위해서는 다음 세 가지의 요소가 필요

	// ① 배열명: 변수처럼 배열의 이름을 짓는다
	// ② 자료형: 배열에 포함될 데이터의 타입을 결정
	// ③ 배열의 길이: 배열에 포함될 데이터의 개수

	// ex)
	// int myArr[3];
	// 배열명: myArr
	// 자료형: int
	// 배열의 길이: [3]

	// 1차원 배열의 초기화 방법
	int myArr[3] = { 1, 2, 3 };

	// 길이가 3인 배열을 초기화하면 메모리 공간에는
	// 4byte 공간 3개가 나란히 할당되고
	// 각각의 공간에 1, 2, 3이 순서대로 저장된다

	// 초기화 리스트를 이용한 배열의 초기화는 반드시
	// 배열의 선언과 동시에 이루어져야 한다

	// 배열을 초기화할 때는 배열의 길이를 생략할 수 있다
	int iArr[] = { 1, 2, 3, 4, 5 };
	// 이 경우 컴파일러가 초기화 리스트에 들어있는
	// 데이터의 개수만큼 메모리에 공간을 할당해 준다

	// 배열에 대한 접근
	// 배열을 생성한 후 저장되어 있는 데이터에 접근하는 방법
	int arr[3] = { 10, 20, 30 };

	// ※ arr[인덱스번호];
	//	인덱스: 배열의 위치를 나타내는 정수값
	//	0번부터 시작함

	printf("%d\n", arr[0]);
	// 출력값: 10 (맨 첫번째를 0으로 봄)

	// 배열의 각각의 방에 다른 값을 대입하는 것도 가능하다
	arr[0] = 50;
	printf("%d\n", arr[0]);

	int odd[3]; // 배열의 선언 (아직 아무 값도 들어 있지 않음)

	// 배열을 선언한 이후에는 초기화 리스트로 초기화를 하는 것이 불가능
	// 이렇게 하는 것이 안 됨 ▶ odd[3] = { 1, 2, 3 };

	// 각각의 방에 접근해서 대입을 해야 한다
	odd[0] = 1;
	odd[1] = 3;
	odd[2] = 5;

	printf("%d %d %d\n", odd[0], odd[1], odd[2]);

	int even[] = { 2, 4, 6, 8, 10 };
	// 배열 안에 들어가 있는 데이터가 많을수록 데이터 출력이 힘들지 않냐!
	// ▶ 
	for (int i = 0; i < 5; i++) {
		printf("%d ", even[i]);
	}
	printf("\n----------------------------\n");

	int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};

	// numbers 요소의 총합
	int total = 0;
	int count = 1;
	for (int i = 0; i < sizeof(numbers) / sizeof(numbers[0]); i++) {
		total += numbers[i];
		count++;
	}
	printf("모든 요소의 총합: %d\n", total);
	// numbers 요소의 평균
	double avg = (double)total / count;
	printf("평균: %.1f", avg);
	}