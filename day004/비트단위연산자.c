#include <stdio.h>

void main() {
	// 비트 단위 연산자
	// 값을 비트 단위로 쪼개서 연산하는 연산자
	// 연산이 되는 바탕이 2진수이다 (1, 0만 존재)
	// 암호화, 복호화에 관련이 있기 때문에 정보보안과 관련이 깊음

	// ① 비트 논리 연산자
	// 논리 연산자(참과 거짓)와 기능은 같지만 연산을 비트 단위로 진행하는 연산자
	// & : AND → 대응하는 각 비트의 값이 1이면 1, 아니면 0 (논리 연산자식 표기: &&)
	// | : OR → 대응하는 각 비트의 값 중 하나라도 1이면 1, 아니면 0 ( "" : ||)
	// 이 I (OR)은 1이나 0을 반환하는 것이 아니다!!!
	// ^(caret) : XOR 대응하는 각 비트의 값이 달라야 1, 같으면 0으로 반환
	// ~ : NOT 비트의 값이 1이면 0, 0이면 1로 반전

	int a = 3; // (이진법 변환 시, 011이나 C언어에서는 8칸으로 늘려 씀 ▶ 00000011)
	int b = 5; // (101 ▶ 00000101)

	printf("3 & 5 : %d\n", a & b); // 1
	printf("3 | 5 : %d\n", a | b); // 7
	printf("3 ^ 5 : %d\n", a ^ b); // 6
	printf("~ 3 : %d\n", ~a);
	// 2진수는 음수를 표현하는 것이 불가능 (보수 개념 사용)

	printf("--------------------------------\n");

	// 시프트 연산자

	// 왼쪽 시프트 연산자
	// 주어진 숫자만큼 각 비트를 왼쪽으로 n칸 이동시키겠다 (이진수 개념)
	// <<

	// 오른쪽 시프트 연산자
	// 주어진 숫자만큼 각 비트를 오른쪽으로 n칸 이동시키겠다 (이진수 개념)
	// >>

	int c, d;
	c = 1;
	d = c << 2;
	printf("%d << 2: %d\n", c, d);

	d = c >> 2;
	printf("%d >> 2: %d\n", c, d);
	

}